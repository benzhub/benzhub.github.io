<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2024/01 on BenzHub</title><link>https://benzhub.github.io/archives/2024/01/</link><description>Recent content in 2024/01 on BenzHub</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://benzhub.github.io/archives/2024/01/index.xml" rel="self" type="application/rss+xml"/><item><title>Big O &amp; 時間複雜度 &amp; 空間複雜度 介紹(Big O &amp; Time Complexity &amp; Space Complexity) | 資料結構&amp;演算法</title><link>https://benzhub.github.io/post/javascript/data-structures-algorithms/001-bigo-complexity/</link><pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/data-structures-algorithms/001-bigo-complexity/</guid><description>&lt;blockquote>
&lt;p>時間和空間複雜度對於開發可擴展和高性能的程式碼影響深遠。我們將入門資料結構&amp;amp;演算法的世界，首先介紹Big O表示法，並演示如何分析和優化JavaScript 程式碼，藉由改善程式的演算法來獲得更好的效能。&lt;/p>
&lt;/blockquote></description></item><item><title>Pipes | Linux</title><link>https://benzhub.github.io/post/linux/014-pipes/</link><pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/014-pipes/</guid><description>&lt;blockquote>
&lt;p>管道(Pipes)實現了命令之間數據的流動，讓Linux 指令能夠創建強大且高效的工作流&lt;/p>
&lt;/blockquote></description></item><item><title>輸入&amp;輸出重定向符號 (Input &amp; Output Streams) | Linux</title><link>https://benzhub.github.io/post/linux/013-input-output-streams/</link><pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/013-input-output-streams/</guid><description>&lt;blockquote>
&lt;p>輸入&amp;amp;輸出重定向符號 (Input &amp;amp; Output Streams)是許多程式在運行時，輸出log或是判斷發生error的常用方式，這個章節的技巧對於日常的系統運維可說是至關重要。&lt;/p>
&lt;/blockquote></description></item><item><title>通配符和替換 (Wildcard &amp; Replacements) | Linux</title><link>https://benzhub.github.io/post/linux/012-wildcard-replacement/</link><pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/012-wildcard-replacement/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>Linux&lt;/strong> 系統中，通配符和替換是搜尋和操作文件或目錄的強大工具&lt;/p>
&lt;/blockquote></description></item><item><title>Bash History | Linux</title><link>https://benzhub.github.io/post/linux/007-bash-history/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/007-bash-history/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Bash&lt;/strong> 歷史紀錄你輸入的命令，提供方便的方式來查看和重複使用它們。用戶可以使用各種命令和快捷方式與此歷史交互&lt;/p>
&lt;/blockquote></description></item><item><title>CLI Shortcuts | Linux</title><link>https://benzhub.github.io/post/linux/008-cli-shortcuts-yank/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/008-cli-shortcuts-yank/</guid><description>&lt;blockquote>
&lt;p>掌握Linux命令行界面（CLI）可以提高效率和靈活性。我們將介紹一系列基本的Linux CLI Shortcuts方式。&lt;/p>
&lt;/blockquote></description></item><item><title>Signals(信號) | Linux</title><link>https://benzhub.github.io/post/linux/009-signals/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/009-signals/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Linux&lt;/strong> 命令行界面使用信號作為進程之間的通信，了解 &lt;strong>Linux&lt;/strong> 信號對於管理和與運行中的進程非常重要。&lt;/p>
&lt;/blockquote></description></item><item><title>什麼是 Mac Address 、 IP 、 Subnet Mask 和 Gateway | 網絡通訊</title><link>https://benzhub.github.io/post/networking/001-macaddress-ip-subnetmask-gateway/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/networking/001-macaddress-ip-subnetmask-gateway/</guid><description>&lt;blockquote>
&lt;p>在網絡通訊領域中，理解設備間通訊的基本概念非常重要。Mac Address 、 IP 、 Subnet Mask 和 Gateway。我們透過演示命令行深入講解各個的意義。&lt;/p>
&lt;/blockquote></description></item><item><title>什麼是Linux ? | Linux</title><link>https://benzhub.github.io/post/linux/006-what-is-linux/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/006-what-is-linux/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Linux&lt;/strong> 是一個類似 &lt;strong>Unix&lt;/strong> 的操作系統內核，最初由Linus Torvalds於1991年創建。&lt;/p>
&lt;/blockquote></description></item><item><title>什麼是Unix ? | Linux</title><link>https://benzhub.github.io/post/linux/005-what-is-unix/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/005-what-is-unix/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Unix&lt;/strong> 誕生於20世紀70年代初的貝爾實驗室，是許多操作系統的祖先， &lt;strong>Unix&lt;/strong> 以其穩健性、可擴展性和多用途性而聞名。&lt;/p>
&lt;/blockquote></description></item><item><title>掌握Linux文件操作: 創建和移動文件 | Linux</title><link>https://benzhub.github.io/post/linux/011-creating-moving-files/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/011-creating-moving-files/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>Linux&lt;/strong> 命令行領域，熟練地創建和移動文件是一項基本技能。這項技能通常會是你在工作上使用 &lt;strong>Linux&lt;/strong> 系統時，最常使用的一個命令行。&lt;/p>
&lt;/blockquote></description></item><item><title>讀取文件(Reading Files) | Linux</title><link>https://benzhub.github.io/post/linux/010-reading-files/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/010-reading-files/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>Linux&lt;/strong> 環境中，通過命令行閱讀文件的技巧是最基本的技巧。文件閱讀是 &lt;strong>Linux&lt;/strong> 日常操作中最常用的命令之一 。&lt;/p>
&lt;/blockquote></description></item><item><title> this | Javascript</title><link>https://benzhub.github.io/post/javascript/032-this/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/032-this/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 中的 &lt;strong>this&lt;/strong> 既強大又神秘，常常讓開發人員感到困惑。我們將用範例深入探討 &lt;strong>this&lt;/strong> 在不同情境中的運作方式。&lt;/p>
&lt;/blockquote></description></item><item><title> Variable Hoisting and Temporal Dead Zone | Javascript</title><link>https://benzhub.github.io/post/javascript/031-variable-hoisting/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/031-variable-hoisting/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Hoisting&lt;/strong> 和 &lt;strong>Temporal Dead Zone(TDZ)&lt;/strong> 影響 &lt;strong>JavaScript&lt;/strong> 中的變量聲明和初始化。 &lt;strong>var&lt;/strong> . &lt;strong>let&lt;/strong> . &lt;strong>const&lt;/strong> 有各自不同的 &lt;strong>Hoisting&lt;/strong> 和 &lt;strong>TDZ&lt;/strong> 情境，這篇文章將會深入介紹這些的細節。&lt;/p>
&lt;/blockquote></description></item><item><title>display 屬性 (block &amp; inline) | CSS</title><link>https://benzhub.github.io/post/htmlcss/020-display-block-inline/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/htmlcss/020-display-block-inline/</guid><description>&lt;blockquote>
&lt;p>CSS &lt;strong>display&lt;/strong> 屬性基本上分為兩個值： &lt;strong>block&lt;/strong> 和 &lt;strong>inline&lt;/strong> ，賦予開發人員控制HTML元素佈局和呈現的能力。&lt;/p>
&lt;/blockquote></description></item><item><title>Float(浮動) | CSS</title><link>https://benzhub.github.io/post/htmlcss/018-float/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/htmlcss/018-float/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>CSS&lt;/strong> 的 &lt;strong>float&lt;/strong> 使開發人員能夠創建具有多個元素的布局。儘管現代佈局技術，如 &lt;strong>Flexbox&lt;/strong> 和 &lt;strong>Grid&lt;/strong> 越來越受歡迎，但理解並利用 &lt;strong>float&lt;/strong> 仍然至關重要。&lt;/p>
&lt;/blockquote></description></item><item><title>JavaScript作用域(Scope) | Javascript</title><link>https://benzhub.github.io/post/javascript/030-javascript-scope/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/030-javascript-scope/</guid><description>&lt;blockquote>
&lt;p>作用域(Scope)代表你宣告的變數可以在哪些區域作用， &lt;strong>JavaScript&lt;/strong> 新手開發人員常常會因為變數作用域在錯誤的區域使用變數，而造成許多隱密的bug。&lt;/p>
&lt;/blockquote></description></item><item><title>Primitive vs. Reference Types | Javascript</title><link>https://benzhub.github.io/post/javascript/033-primitive-reference/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/033-primitive-reference/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 是一種動態且多用途的編程語言，數據基本有2種類型: &lt;strong>原始類型&lt;/strong> 和 &lt;strong>參考類型&lt;/strong> 。&lt;/p>
&lt;/blockquote></description></item><item><title>定位屬性 position relative absolute | CSS</title><link>https://benzhub.github.io/post/htmlcss/021-position-relative-absolute/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/htmlcss/021-position-relative-absolute/</guid><description>&lt;blockquote>
&lt;p>在Web佈局上，CSS提供了一個強大的工具：position: relative 和 position: absolute。這兩個屬性在定位元素在文檔中的位置方面起著關鍵作用。&lt;/p>
&lt;/blockquote></description></item><item><title>淺拷貝 vs. 深拷貝 (Shallow Copy vs. Deep Copy) | Javascript</title><link>https://benzhub.github.io/post/javascript/034-shallow-copy-vs-deep-copy/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/034-shallow-copy-vs-deep-copy/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>JavaScript&lt;/strong> 中，複製對象和陣列是一個常見的任務，但複製的方法可能導致意外的行為。淺拷貝和深拷貝是兩種不同的方法，各自具有其優勢和用例。&lt;/p>
&lt;/blockquote></description></item><item><title>表單樣式(Form Style) | CSS</title><link>https://benzhub.github.io/post/htmlcss/022-form-style/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/htmlcss/022-form-style/</guid><description>&lt;blockquote>
&lt;p>CSS表單樣式通常會出現在用戶登入或是輸入資料的地方，對於用戶的使用體驗有很高的影響性。本篇文章將會跟你介紹HTML&amp;amp;CSS中表單的樣式設計。&lt;/p>
&lt;/blockquote></description></item><item><title>超連結(HyperLink)和按鈕(Button)(hover, active, visited, focus, cursor) | CSS</title><link>https://benzhub.github.io/post/htmlcss/019-hyperlink-button/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/htmlcss/019-hyperlink-button/</guid><description>&lt;blockquote>
&lt;p>網頁中有兩個重要的用戶互動元素——超鏈接和按鈕，我們將介紹使用CSS來增強它們的外觀和互動性。&lt;/p>
&lt;/blockquote></description></item><item><title>陣列解構(Destructuring Arrays) | Javascript</title><link>https://benzhub.github.io/post/javascript/035-destructuring-arrays/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/035-destructuring-arrays/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 陣列解構(Destructuring Arrays)是一個強大的功能，允許開發人員以優雅和簡潔的方式從陣列中提取值，它簡化了代碼，使其更直觀且更易讀。&lt;/p>
&lt;/blockquote></description></item><item><title>JavaScript引擎和執行的深度剖析 | JavaScript</title><link>https://benzhub.github.io/post/javascript/029-javascript-engine-and-runtime/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/029-javascript-engine-and-runtime/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 引擎和運行(JavaScript Engine and Runtime)是執行和管理 &lt;strong>JavaScript&lt;/strong> 代碼的核心組件。我們介紹各元件的複雜性，闡明它們如何共同工作，使 &lt;strong>JavaScript&lt;/strong> 高效又完美的執行。&lt;/p>
&lt;/blockquote></description></item><item><title>Linux or Mac 安裝 nvm(Node.js 的版本管理器) | Javascript</title><link>https://benzhub.github.io/post/javascript/024-linux-or-mac-install-nvm-copy/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/024-linux-or-mac-install-nvm-copy/</guid><description>&lt;blockquote>
&lt;p>管理 &lt;strong>Node.js&lt;/strong> 版本對很多人來說是一場惡夢，但使用 &lt;strong>nvm&lt;/strong> （Node.js版本管理器），這個過程變得簡單而高效。我們將介紹如何在Linux和Mac OS 系統安裝 &lt;strong>nvm&lt;/strong> ，使他們能夠輕鬆切換 &lt;strong>Node.js&lt;/strong> 版本。&lt;/p>
&lt;/blockquote></description></item><item><title>事件處理(Handling Events) | Javascript</title><link>https://benzhub.github.io/post/javascript/026-handling-click-events/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/026-handling-click-events/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>JavaScript&lt;/strong> 中，事件驅動允許開發者創建與使用者互動的網頁。&lt;/p>
&lt;/blockquote></description></item><item><title>什麼是 nvm、npm、Node.js | Javascript</title><link>https://benzhub.github.io/post/javascript/023-whats-nvm-npm-nodejs/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/023-whats-nvm-npm-nodejs/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Node.js&lt;/strong> 已成為現代Web開發的基石，其生態系統包括 &lt;strong>npm&lt;/strong> （Node包管理器）和 &lt;strong>nvm&lt;/strong> （Node版本管理器）等重要工具。理解 &lt;strong>Node.js&lt;/strong> 、 &lt;strong>npm&lt;/strong> 和 &lt;strong>nvm&lt;/strong> 之間的關係對於乾淨的套件管理和版本控制非常重要。&lt;/p>
&lt;/blockquote></description></item><item><title>使用javascript改變CSS style | Javascript</title><link>https://benzhub.github.io/post/javascript/027-changing-css-styles/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/027-changing-css-styles/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 使開發人員能夠動態更改HTML元素和修改CSS樣式。&lt;/p>
&lt;/blockquote></description></item><item><title>按鍵事件處理(Handling Keypress Events) | Javascript</title><link>https://benzhub.github.io/post/javascript/028-handling-keypress-events/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/028-handling-keypress-events/</guid><description>&lt;blockquote>
&lt;p>我們將在這篇文章中介紹 &lt;strong>JavaScript&lt;/strong> 中按鍵事件處理的方式。&lt;/p>
&lt;/blockquote></description></item><item><title>選擇元素(Selecting DOM Elements) | Javascript</title><link>https://benzhub.github.io/post/javascript/025-selecting-dom-elements/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/025-selecting-dom-elements/</guid><description>&lt;blockquote>
&lt;p>在DOM（文檔對象模型）中選擇元素是 &lt;strong>JavaScript&lt;/strong> 開發人員的基本技能。透過操作HTML元素，讓我們的網頁增加更多靈活的互動性。我們將介紹使用 &lt;strong>JavaScript&lt;/strong> 選擇元素的不同方法。&lt;/p>
&lt;/blockquote></description></item></channel></rss>