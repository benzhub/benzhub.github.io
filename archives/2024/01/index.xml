<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2024/01 on BenzHub</title><link>https://benzhub.github.io/archives/2024/01/</link><description>Recent content in 2024/01 on BenzHub</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://benzhub.github.io/archives/2024/01/index.xml" rel="self" type="application/rss+xml"/><item><title>遍歷物件鍵和值Object.keys()、Object.values() 、 Object.entries() | Javascript</title><link>https://benzhub.github.io/post/javascript/046-looping-objects-keys-values-entries/</link><pubDate>Wed, 17 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/046-looping-objects-keys-values-entries/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>JavaScript&lt;/strong> 中，遍歷物件的屬性是一個常見的任務。ES6 引入了一些新的方法來更輕鬆地遍歷物件的屬性，其中包括 &lt;strong>Object.keys()&lt;/strong> 、 &lt;strong>Object.values()&lt;/strong> 和 &lt;strong>Object.entries()&lt;/strong> 。&lt;/p>
&lt;/blockquote></description></item><item><title>Optional Chaining(可選鏈) | Javascript</title><link>https://benzhub.github.io/post/javascript/045-optional-chaining/</link><pubDate>Tue, 16 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/045-optional-chaining/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 中的 &lt;strong>Optional Chaining（可選鏈）&lt;/strong> 是一種語法，用於簡化對可能為undefined或null的屬性或方法的訪問。這種語法在處理物件或陣列的多層屬性時特別有用，可以避免因為中途某一個屬性為undefined或null而導致程式出錯。&lt;/p>
&lt;/blockquote></description></item><item><title>for of 循環 &amp; entries()獲取索引 | Javascript</title><link>https://benzhub.github.io/post/javascript/044-for-of-entries/</link><pubDate>Mon, 15 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/044-for-of-entries/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>JavaScript&lt;/strong> 中， &lt;strong>for&amp;hellip;of&lt;/strong> 循環是一種用於迭代的語法結構。它特別適用於遍歷陣列元素。在使用 &lt;strong>for&amp;hellip;of&lt;/strong> 循環時，我們可以方便地獲取陣列中的每個元素，而不必關心索引的細節。此外，結合 &lt;strong>entries()&lt;/strong> 方法使用 &lt;strong>for&amp;hellip;of&lt;/strong> 循環，我們還可以獲取陣列元素的索引。&lt;/p>
&lt;/blockquote></description></item><item><title>展開運算子(Spread Operation) | Javascript</title><link>https://benzhub.github.io/post/javascript/043-short-circuiting/</link><pubDate>Sat, 13 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/043-short-circuiting/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 中的 &lt;strong>短路運算（Short-circuit evaluation）&lt;/strong> 是一種邏輯運算的行為，它基於邏輯運算符（如 &lt;strong>&amp;amp;&amp;amp;&lt;/strong> 和 &lt;strong>||&lt;/strong> ）的特性來提升開發程式碼的效率。短路運算允許在達到確定結果的情況下提前結束表達式的計算。&lt;/p>
&lt;/blockquote></description></item><item><title>展開運算子(Spread Operation) | Javascript</title><link>https://benzhub.github.io/post/javascript/042-spread-operator/</link><pubDate>Fri, 12 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/042-spread-operator/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 中的展開運算子是一種語法，通常用於將可迭代物件（例如陣列或字串）展開為其各個元素，或者用於合併物件的屬性。這個操作符由三個連續的點（&amp;hellip;）組成。&lt;/p>
&lt;/blockquote></description></item><item><title>後綴遞增(value++) VS 前綴遞增(++value) VS 使用賦值運算符遞增(value += 1) | Javascript</title><link>https://benzhub.github.io/post/javascript/041-postfix-prefix/</link><pubDate>Thu, 11 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/041-postfix-prefix/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>JavaScript&lt;/strong> 中的遞增或遞減運算子中，例如: &lt;strong>value++&lt;/strong> 、 &lt;strong>++value&lt;/strong> 和 &lt;strong>value += 1&lt;/strong> 都是用於增加變數值的操作，但它們之間有一些差異。&lt;/p>
&lt;/blockquote></description></item><item><title>解構物件(Destructuring Objects) | Javascript</title><link>https://benzhub.github.io/post/javascript/040-destructuring-objects/</link><pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/040-destructuring-objects/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>JavaScript&lt;/strong> 中， &lt;strong>物件解構（ Object Destructuring）&lt;/strong> 是一種方便的語法，用於從物件中提取屬性並將其賦值給變數。這種語法有助於簡化程式碼，尤其是在處理包含大量property的物件時。&lt;/p>
&lt;/blockquote></description></item><item><title>Linked list (鏈結串列) | 資料結構&amp;演算法</title><link>https://benzhub.github.io/post/javascript/data-structures-algorithms/002-linked-list/</link><pubDate>Tue, 09 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/data-structures-algorithms/002-linked-list/</guid><description>&lt;blockquote>
&lt;p>資料結構 &lt;strong>鏈結串列（Linked List）&lt;/strong> 是一種基本的資料結構，用於存儲一系列元素。在 &lt;strong>JavaScript&lt;/strong> 中，可以使用物件來實現鏈結串列。鏈結串列由節點（Node）組成，每個節點包含一個數據元素和一個指向下一個節點的連結。&lt;/p>
&lt;/blockquote></description></item><item><title>前端的重試、超時與退避策略（Backoff Strategy） | Javascript</title><link>https://benzhub.github.io/post/javascript/039-backoff-strategy/</link><pubDate>Mon, 08 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/039-backoff-strategy/</guid><description>&lt;blockquote>
&lt;p>前端的重試、超時與退避策略（Backoff Strategy）是一種處理網路請求失敗和重試的策略。主要是在面對瞬間的網路問題或伺服器出錯的情況下，有效地減少對伺服器的大量重複請求，以避免對伺服器和網路造成過載。 &lt;strong>重試、超時與退避策略的核心思想是在每次請求失敗後，逐漸增加重新請求的時間間隔。&lt;/strong>&lt;/p>
&lt;/blockquote></description></item><item><title>前端輪循(Frontend polling)技巧 | Javascript</title><link>https://benzhub.github.io/post/javascript/038-frontend-polling/</link><pubDate>Mon, 08 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/038-frontend-polling/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>前端輪詢（Frontend Polling）&lt;/strong> 是一種用於實現實時數據更新的簡單通信方法。它通過定期向伺服器發送請求來檢查是否有新的數據可用。輪詢是一種基本的客戶端-伺服器通信模型，儘管在現代開發中，使用 WebSocket 或 Server-Sent Events 等技術通常更為高效和實時，但在某些情況下仍然是有效的。&lt;/p>
&lt;/blockquote></description></item><item><title>集合(Sets) | Javascript</title><link>https://benzhub.github.io/post/javascript/037-set/</link><pubDate>Mon, 08 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/037-set/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>JavaScript&lt;/strong> 中， &lt;strong>Set&lt;/strong> 是一種集合（Collection）數據類型，用於存儲唯一值，即集合中的元素不能重複。 &lt;strong>Set&lt;/strong> 是ES6（ECMAScript 2015）引入的新數據類型之一，它提供了一種簡單而有效的方法來存儲和管理一組唯一的值。&lt;/p>
&lt;/blockquote></description></item><item><title>TypeScript中的 typeof 優雅的用法 | TypeScript</title><link>https://benzhub.github.io/post/javascript/typescript/004-typeof/</link><pubDate>Sat, 06 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/typescript/004-typeof/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>typeof&lt;/strong> 允許開發人員獲取變量或表達式的類型，在 &lt;strong>TypeScript&lt;/strong> 中，通常會先寫類型，然後宣告時再附上定義的型別， &lt;strong>typeof&lt;/strong> 可以讓複雜的物件直接轉化出型別，讓我們的定義型別可以更優雅&lt;/p>
&lt;/blockquote></description></item><item><title>常用的Utility和範例 | TypeScript</title><link>https://benzhub.github.io/post/javascript/typescript/005-utility/</link><pubDate>Sat, 06 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/typescript/005-utility/</guid><description>&lt;blockquote>
&lt;p>使 &lt;strong>TypeScript&lt;/strong> 的其中一個關鍵特點就是它的 &lt;strong>Utility&lt;/strong> 。我們將介紹20個 &lt;strong>TypeScript Utility&lt;/strong> 和範例，並講解使用的優勢。&lt;/p>
&lt;/blockquote></description></item><item><title>Lists Tuples Sets Dictionary(列表 元組 集合 字典) | Python</title><link>https://benzhub.github.io/post/python/004-lists-tuples-sets-dicts/</link><pubDate>Fri, 05 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/python/004-lists-tuples-sets-dicts/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Python&lt;/strong> 的數據每種結構都針對特定用例而設計。我們這邊利用範例展示 &lt;strong>Python&lt;/strong> 的列表、元組、集合和字典，展示它們如何能夠高效處理數據。&lt;/p>
&lt;/blockquote></description></item><item><title>基本類型(Basic Types) | TypeScript</title><link>https://benzhub.github.io/post/javascript/typescript/002-basic-types/</link><pubDate>Fri, 05 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/typescript/002-basic-types/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>TypeScript&lt;/strong> ，作為 &lt;strong>JavaScript&lt;/strong> 的超集，引入了靜態類型，使得程式碼更加可靠且易於維護。&lt;strong>TypeScript&lt;/strong> 的基本類型使開發人員可以在開發前期就發現許多隱密的型別錯誤，在大型多人協作專案中，這種明確的型別優勢就特別巨大，因此 &lt;strong>Typescript&lt;/strong> 在大型專案中使用率逐漸超越了 &lt;strong>JavaScript&lt;/strong> 。&lt;/p>
&lt;/blockquote></description></item><item><title>文字類型(Literal Types) | TypeScript</title><link>https://benzhub.github.io/post/javascript/typescript/001-literal-types/</link><pubDate>Fri, 05 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/typescript/001-literal-types/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>TypeScript&lt;/strong> 的領域中，有一個強大的功能被稱為 &lt;strong>文字類型&lt;/strong> ，它使開發人員能夠使用確切的值而不是通用類型。這提供了更強大的類型安全性和更精準的程式碼。&lt;/p>
&lt;/blockquote></description></item><item><title>物件類型(Objects Types) | TypeScript</title><link>https://benzhub.github.io/post/javascript/typescript/003-objects-types/</link><pubDate>Fri, 05 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/typescript/003-objects-types/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>TypeScript&lt;/strong> 物件類型在定義程式碼中的資料結構和型別方面發揮了關鍵作用。它提供了一種創建明確定義物件模式的方式，有助於提高程式碼的可讀性和可維護性，特別在物件導向開發時，會大量使用。&lt;/p>
&lt;/blockquote></description></item><item><title>高級集合操作 (Advanced Set Operations) | Javascript</title><link>https://benzhub.github.io/post/javascript/036-advanced-set-operations/</link><pubDate>Fri, 05 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/036-advanced-set-operations/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 使用高級集合操作高效處理數據，使用Set對象進行操作，2組資料重複的元素(集合的交集)、2組資料不重複的元素(差集)和2組資料元素合併且都不重複(聯集)，在實際應用場景，運用這些高效地集合方式整理資料。&lt;/p>
&lt;/blockquote></description></item><item><title>Big O &amp; 時間複雜度 &amp; 空間複雜度 介紹(Big O &amp; Time Complexity &amp; Space Complexity) | 資料結構&amp;演算法</title><link>https://benzhub.github.io/post/javascript/data-structures-algorithms/001-bigo-complexity/</link><pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/data-structures-algorithms/001-bigo-complexity/</guid><description>&lt;blockquote>
&lt;p>時間和空間複雜度對於開發可擴展和高性能的程式碼影響深遠。我們將入門資料結構&amp;amp;演算法的世界，首先介紹 &lt;strong>Big O&lt;/strong> 表示法，並演示如何分析和優化 &lt;strong>JavaScript&lt;/strong> 程式碼，藉由改善程式的演算法來獲得更好的效能。&lt;/p>
&lt;/blockquote></description></item><item><title>管道(Pipes) | Linux</title><link>https://benzhub.github.io/post/linux/014-pipes/</link><pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/014-pipes/</guid><description>&lt;blockquote>
&lt;p>管道(Pipes)實現了命令之間數據的流動，讓Linux 指令能夠創建強大且高效的工作流。&lt;/p>
&lt;/blockquote></description></item><item><title>輸入&amp;輸出重定向符號 (Input &amp; Output Streams) | Linux</title><link>https://benzhub.github.io/post/linux/013-input-output-streams/</link><pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/013-input-output-streams/</guid><description>&lt;blockquote>
&lt;p>輸入&amp;amp;輸出重定向符號 (Input &amp;amp; Output Streams)是許多程式在運行時，輸出log或是判斷發生error的常用方式，這個章節的技巧對於日常的系統運維可說是至關重要。&lt;/p>
&lt;/blockquote></description></item><item><title>通配符和替換 (Wildcard &amp; Replacements) | Linux</title><link>https://benzhub.github.io/post/linux/012-wildcard-replacement/</link><pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/012-wildcard-replacement/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>Linux&lt;/strong> 系統中，通配符和替換是搜尋和操作文件或目錄的強大工具。&lt;/p>
&lt;/blockquote></description></item><item><title>高級集合操作 (Advanced Set Operations)| Python</title><link>https://benzhub.github.io/post/python/005-advanced-set-operations/</link><pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/python/005-advanced-set-operations/</guid><description>&lt;blockquote>
&lt;p>我們將介紹 &lt;strong>Python&lt;/strong> 中的高級Set(集合)操作，包括交集、聯集、差集、對稱差集等，以及如何在實際應用中充分利用這些操作。&lt;/p>
&lt;/blockquote></description></item><item><title>Bash History | Linux</title><link>https://benzhub.github.io/post/linux/007-bash-history/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/007-bash-history/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Bash&lt;/strong> 歷史紀錄你輸入的命令，提供方便的方式來查看和重複使用它們。用戶可以使用各種命令和快捷方式與此歷史交互。&lt;/p>
&lt;/blockquote></description></item><item><title>CLI Shortcuts | Linux</title><link>https://benzhub.github.io/post/linux/008-cli-shortcuts-yank/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/008-cli-shortcuts-yank/</guid><description>&lt;blockquote>
&lt;p>掌握 &lt;strong>Linux&lt;/strong> 命令行界面（CLI）可以提高效率和靈活性。我們將介紹一系列基本的 &lt;strong>Linux CLI Shortcuts&lt;/strong> 方式。&lt;/p>
&lt;/blockquote></description></item><item><title>Signals(信號) | Linux</title><link>https://benzhub.github.io/post/linux/009-signals/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/009-signals/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Linux&lt;/strong> 命令行界面使用信號作為進程之間的通信，了解 &lt;strong>Linux&lt;/strong> 信號對於管理和與運行中的進程非常重要。&lt;/p>
&lt;/blockquote></description></item><item><title>什麼是 Mac Address 、 IP 、 Subnet Mask 和 Gateway | 網絡通訊</title><link>https://benzhub.github.io/post/networking/001-macaddress-ip-subnetmask-gateway/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/networking/001-macaddress-ip-subnetmask-gateway/</guid><description>&lt;blockquote>
&lt;p>在網絡通訊領域中，理解設備間通訊的基本概念非常重要。 &lt;strong>Mac Address&lt;/strong> 、 &lt;strong>IP&lt;/strong> 、 &lt;strong>Subnet Mask&lt;/strong> 和 &lt;strong>Gateway&lt;/strong> 。我們透過演示命令行深入講解各個的意義。&lt;/p>
&lt;/blockquote></description></item><item><title>什麼是Linux ? | Linux</title><link>https://benzhub.github.io/post/linux/006-what-is-linux/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/006-what-is-linux/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Linux&lt;/strong> 是一個類似 &lt;strong>Unix&lt;/strong> 的操作系統內核，最初由 &lt;strong>Linus Torvalds&lt;/strong> 於1991年創建。&lt;/p>
&lt;/blockquote></description></item><item><title>什麼是Unix ? | Linux</title><link>https://benzhub.github.io/post/linux/005-what-is-unix/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/005-what-is-unix/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Unix&lt;/strong> 誕生於20世紀70年代初的貝爾實驗室，是許多操作系統的祖先， &lt;strong>Unix&lt;/strong> 以其穩健性、可擴展性和多用途性而聞名。&lt;/p>
&lt;/blockquote></description></item><item><title>掌握Linux文件操作: 創建和移動文件 | Linux</title><link>https://benzhub.github.io/post/linux/011-creating-moving-files/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/011-creating-moving-files/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>Linux&lt;/strong> 命令行領域，熟練地創建和移動文件是一項基本技能。這項技能通常會是你在工作上使用 &lt;strong>Linux&lt;/strong> 系統時，最常使用的一個命令行。&lt;/p>
&lt;/blockquote></description></item><item><title>讀取文件(Reading Files) | Linux</title><link>https://benzhub.github.io/post/linux/010-reading-files/</link><pubDate>Wed, 03 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/linux/010-reading-files/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>Linux&lt;/strong> 環境中，通過命令行閱讀文件的技巧是最基本的技巧。文件閱讀是 &lt;strong>Linux&lt;/strong> 日常操作中最常用的命令之一 。&lt;/p>
&lt;/blockquote></description></item><item><title> this | Javascript</title><link>https://benzhub.github.io/post/javascript/032-this/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/032-this/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 中的 &lt;strong>this&lt;/strong> 既強大又神秘，常常讓開發人員感到困惑。我們將用範例深入探討 &lt;strong>this&lt;/strong> 在不同情境中的運作方式。&lt;/p>
&lt;/blockquote></description></item><item><title> Variable Hoisting and Temporal Dead Zone | Javascript</title><link>https://benzhub.github.io/post/javascript/031-variable-hoisting/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/031-variable-hoisting/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Hoisting&lt;/strong> 和 &lt;strong>Temporal Dead Zone(TDZ)&lt;/strong> 影響 &lt;strong>JavaScript&lt;/strong> 中的變量聲明和初始化。 &lt;strong>var&lt;/strong> . &lt;strong>let&lt;/strong> . &lt;strong>const&lt;/strong> 有各自不同的 &lt;strong>Hoisting&lt;/strong> 和 &lt;strong>TDZ&lt;/strong> 情境，這篇文章將會深入介紹這些的細節。&lt;/p>
&lt;/blockquote></description></item><item><title>display 屬性 (block &amp; inline) | CSS</title><link>https://benzhub.github.io/post/htmlcss/020-display-block-inline/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/htmlcss/020-display-block-inline/</guid><description>&lt;blockquote>
&lt;p>CSS &lt;strong>display&lt;/strong> 屬性基本上分為兩個值： &lt;strong>block&lt;/strong> 和 &lt;strong>inline&lt;/strong> ，賦予開發人員控制HTML元素佈局和呈現的能力。&lt;/p>
&lt;/blockquote></description></item><item><title>Float(浮動) | CSS</title><link>https://benzhub.github.io/post/htmlcss/018-float/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/htmlcss/018-float/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>CSS&lt;/strong> 的 &lt;strong>float&lt;/strong> 使開發人員能夠創建具有多個元素的布局。儘管現代佈局技術，如 &lt;strong>Flexbox&lt;/strong> 和 &lt;strong>Grid&lt;/strong> 越來越受歡迎，但理解並利用 &lt;strong>float&lt;/strong> 仍然至關重要。&lt;/p>
&lt;/blockquote></description></item><item><title>JavaScript作用域(Scope) | Javascript</title><link>https://benzhub.github.io/post/javascript/030-javascript-scope/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/030-javascript-scope/</guid><description>&lt;blockquote>
&lt;p>作用域(Scope)代表你宣告的變數可以在哪些區域作用， &lt;strong>JavaScript&lt;/strong> 新手開發人員常常會因為變數作用域在錯誤的區域使用變數，而造成許多隱密的bug。&lt;/p>
&lt;/blockquote></description></item><item><title>Primitive vs. Reference Types | Javascript</title><link>https://benzhub.github.io/post/javascript/033-primitive-reference/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/033-primitive-reference/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 是一種動態且多用途的程式語言，數據基本有2種類型: &lt;strong>原始類型&lt;/strong> 和 &lt;strong>參考類型&lt;/strong> 。&lt;/p>
&lt;/blockquote></description></item><item><title>定位屬性 position relative absolute | CSS</title><link>https://benzhub.github.io/post/htmlcss/021-position-relative-absolute/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/htmlcss/021-position-relative-absolute/</guid><description>&lt;blockquote>
&lt;p>在Web佈局上， &lt;strong>CSS&lt;/strong> 提供了一個強大的工具：position: relative 和 position: absolute。這兩個屬性在定位元素在文檔中的位置方面起著關鍵作用。&lt;/p>
&lt;/blockquote></description></item><item><title>淺拷貝 vs. 深拷貝 (Shallow Copy vs. Deep Copy) | Javascript</title><link>https://benzhub.github.io/post/javascript/034-shallow-copy-vs-deep-copy/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/034-shallow-copy-vs-deep-copy/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>JavaScript&lt;/strong> 中，複製對象和陣列是一個常見的任務，但複製的方法可能導致意外的行為。淺拷貝和深拷貝是兩種不同的方法，各自具有其優勢和用例。&lt;/p>
&lt;/blockquote></description></item><item><title>表單樣式(Form Style) | CSS</title><link>https://benzhub.github.io/post/htmlcss/022-form-style/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/htmlcss/022-form-style/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>CSS&lt;/strong> 表單樣式通常會出現在用戶登入或是輸入資料的地方，對於用戶的使用體驗有很高的影響性。本篇文章將會跟你介紹 &lt;strong>HTML&amp;amp;CSS&lt;/strong> 中表單的樣式設計。&lt;/p>
&lt;/blockquote></description></item><item><title>超連結(HyperLink)和按鈕(Button)(hover, active, visited, focus, cursor) | CSS</title><link>https://benzhub.github.io/post/htmlcss/019-hyperlink-button/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/htmlcss/019-hyperlink-button/</guid><description>&lt;blockquote>
&lt;p>網頁中有兩個重要的用戶互動元素——超鏈接和按鈕，我們將介紹使用CSS來增強它們的外觀和互動性。&lt;/p>
&lt;/blockquote></description></item><item><title>陣列解構(Destructuring Arrays) | Javascript</title><link>https://benzhub.github.io/post/javascript/035-destructuring-arrays/</link><pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/035-destructuring-arrays/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 陣列解構(Destructuring Arrays)是一個強大的功能，允許開發人員以優雅和簡潔的方式從陣列中提取值，它簡化了代碼，使其更直觀且更易讀。&lt;/p>
&lt;/blockquote></description></item><item><title>JavaScript引擎和執行的深度剖析 | JavaScript</title><link>https://benzhub.github.io/post/javascript/029-javascript-engine-and-runtime/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/029-javascript-engine-and-runtime/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 引擎和運行(JavaScript Engine and Runtime)是執行和管理 &lt;strong>JavaScript&lt;/strong> 代碼的核心組件。我們介紹各元件的複雜性，闡明它們如何共同工作，使 &lt;strong>JavaScript&lt;/strong> 高效又完美的執行。&lt;/p>
&lt;/blockquote></description></item><item><title>Linux or Mac 安裝 nvm(Node.js 的版本管理器) | Javascript</title><link>https://benzhub.github.io/post/javascript/024-linux-or-mac-install-nvm-copy/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/024-linux-or-mac-install-nvm-copy/</guid><description>&lt;blockquote>
&lt;p>管理 &lt;strong>Node.js&lt;/strong> 版本對很多人來說是一場惡夢，但使用 &lt;strong>nvm&lt;/strong> （Node.js版本管理器），這個過程變得簡單而高效。我們將介紹如何在Linux和Mac OS 系統安裝 &lt;strong>nvm&lt;/strong> ，使他們能夠輕鬆切換 &lt;strong>Node.js&lt;/strong> 版本。&lt;/p>
&lt;/blockquote></description></item><item><title>事件處理(Handling Events) | Javascript</title><link>https://benzhub.github.io/post/javascript/026-handling-click-events/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/026-handling-click-events/</guid><description>&lt;blockquote>
&lt;p>在 &lt;strong>JavaScript&lt;/strong> 中，事件驅動允許開發者創建與使用者互動的網頁。&lt;/p>
&lt;/blockquote></description></item><item><title>什麼是 nvm、npm、Node.js | Javascript</title><link>https://benzhub.github.io/post/javascript/023-whats-nvm-npm-nodejs/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/023-whats-nvm-npm-nodejs/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>Node.js&lt;/strong> 已成為現代Web開發的基石，其生態系統包括 &lt;strong>npm&lt;/strong> （Node包管理器）和 &lt;strong>nvm&lt;/strong> （Node版本管理器）等重要工具。理解 &lt;strong>Node.js&lt;/strong> 、 &lt;strong>npm&lt;/strong> 和 &lt;strong>nvm&lt;/strong> 之間的關係對於乾淨的套件管理和版本控制非常重要。&lt;/p>
&lt;/blockquote></description></item><item><title>使用javascript改變CSS style | Javascript</title><link>https://benzhub.github.io/post/javascript/027-changing-css-styles/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/027-changing-css-styles/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>JavaScript&lt;/strong> 使開發人員能夠動態更改 &lt;strong>HTML&lt;/strong> 元素和修改 &lt;strong>CSS&lt;/strong> 樣式。&lt;/p>
&lt;/blockquote></description></item><item><title>按鍵事件處理(Handling Keypress Events) | Javascript</title><link>https://benzhub.github.io/post/javascript/028-handling-keypress-events/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/028-handling-keypress-events/</guid><description>&lt;blockquote>
&lt;p>我們將在這篇文章中介紹 &lt;strong>JavaScript&lt;/strong> 中按鍵事件處理的方式。&lt;/p>
&lt;/blockquote></description></item><item><title>選擇元素(Selecting DOM Elements) | Javascript</title><link>https://benzhub.github.io/post/javascript/025-selecting-dom-elements/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://benzhub.github.io/post/javascript/025-selecting-dom-elements/</guid><description>&lt;blockquote>
&lt;p>在DOM（文檔對象模型）中選擇元素是 &lt;strong>JavaScript&lt;/strong> 開發人員的基本技能。透過操作HTML元素，讓我們的網頁增加更多靈活的互動性。我們將介紹使用 &lt;strong>JavaScript&lt;/strong> 選擇元素的不同方法。&lt;/p>
&lt;/blockquote></description></item></channel></rss>